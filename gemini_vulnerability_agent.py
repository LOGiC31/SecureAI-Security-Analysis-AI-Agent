#!/usr/bin/env python3
"""
LLM Agent for AIxCC AFC Challenge - Patch Generation Only using Gemini API
Following same instructions as perplexity version - no manual analysis, no fallbacks
Focuses only on patch generation and always uses fresh folder
"""

import os
import sys
import time
import subprocess
import requests
import glob
import json
import shutil
from pathlib import Path

class GeminiVulnerabilityAgent:
    def __init__(self, gemini_api_key):
        self.api_key = gemini_api_key
        self.challenge_dir = Path("/home/u335008079/gemini_test/aixcc-sample-challenge")
        self.example_libpng_dir = self.challenge_dir / "example-libpng"
        self.api_url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-pro:generateContent"
        self.original_challenge_dir = Path("/aixcc-sample-challenge")
        self.crash_achieved = False  # Track if we've achieved a successful crash
        self.total_cost = 0.0  # Track total API cost
        self.api_calls = 0  # Track number of API calls
        
    def call_gemini_api(self, prompt, max_retries=3):
        """Call Gemini API with the given prompt"""
        headers = {
            "Content-Type": "application/json"
        }
        
        data = {
            "contents": [
                {
                    "parts": [
                        {
                            "text": prompt
                        }
                    ]
                }
            ],
            "generationConfig": {
                "temperature": 0.1,
                "maxOutputTokens": 4000
            }
        }
        
        for attempt in range(max_retries):
            try:
                response = requests.post(
                    f"{self.api_url}?key={self.api_key}", 
                    headers=headers, 
                    json=data, 
                    timeout=60
                )
                response.raise_for_status()
                
                result = response.json()
                if 'candidates' in result and len(result['candidates']) > 0:
                    candidate = result['candidates'][0]
                    if 'content' in candidate and 'parts' in candidate['content']:
                        # Calculate cost (rough estimate for Gemini 1.5 Pro)
                        # Input: ~$0.00125 per 1K tokens, Output: ~$0.005 per 1K tokens
                        input_tokens = len(prompt.split()) * 1.3  # Rough token estimation
                        output_tokens = len(candidate['content']['parts'][0]['text'].split()) * 1.3
                        call_cost = (input_tokens / 1000 * 0.00125) + (output_tokens / 1000 * 0.005)
                        self.total_cost += call_cost
                        self.api_calls += 1
                        print(f"API call #{self.api_calls} cost: ${call_cost:.4f}")
                        return candidate['content']['parts'][0]['text']
                    else:
                        print(f"Unexpected API response format: {result}")
                        return None
                else:
                    print(f"Unexpected API response format: {result}")
                    return None
                    
            except requests.exceptions.RequestException as e:
                print(f"API call attempt {attempt + 1} failed: {e}")
                if attempt < max_retries - 1:
                    time.sleep(2 ** attempt)
                else:
                    raise
            except Exception as e:
                print(f"Unexpected error in API call attempt {attempt + 1}: {e}")
                if attempt < max_retries - 1:
                    time.sleep(2 ** attempt)
                else:
                    raise
        
        return None
    
    def refresh_challenge_folder(self):
        """Delete and copy fresh challenge folder"""
        print("Refreshing challenge folder...")
        
        # Remove existing folder
        if self.challenge_dir.exists():
            shutil.rmtree(self.challenge_dir)
            print(f"Removed existing folder: {self.challenge_dir}")
        
        # Copy fresh folder
        shutil.copytree(self.original_challenge_dir, self.challenge_dir)
        print(f"Copied fresh folder from {self.original_challenge_dir} to {self.challenge_dir}")
    
    def extract_python_code(self, response):
        """Extract Python code from Gemini response"""
        if "```python" in response:
            start = response.find("```python") + 9
            end = response.find("```", start)
            if end != -1:
                return response[start:end].strip()
        elif "```" in response:
            start = response.find("```") + 3
            end = response.find("```", start)
            if end != -1:
                return response[start:end].strip()
        
        return response.strip()
    
    def cleanup_old_files(self):
        """Clean up old files"""
        old_files = glob.glob("/home/u335008079/gemini_test/gemini_response*.py")
        old_files.extend(glob.glob("/home/u335008079/gemini_test/generated_code*.txt"))
        for file in old_files:
            try:
                os.remove(file)
                print(f"Cleaned up: {file}")
            except Exception as e:
                print(f"Could not remove {file}: {e}")
    
    def read_file_content(self, file_path):
        """Read file content safely"""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                return f.read()
        except Exception as e:
            print(f"Error reading {file_path}: {e}")
            return None
    
    def prepare_context(self):
        """Prepare context files - NO ANALYSIS, just file collection"""
        context_files = {}
        
        # Read the vulnerability diff from exact path in instructions
        diff_path = Path("/home/u335008079/gemini_test/aixcc-sample-challenge/diff")
        context_files["old_diff"] = self.read_file_content(diff_path)
        
        # Extract affected files from diff
        diff_content = context_files["old_diff"]
        affected_files = []
        if diff_content:
            lines = diff_content.split('\n')
            for line in lines:
                if line.startswith('diff --git a/') or line.startswith('+++ b/') or line.startswith('--- a/'):
                    if 'b/' in line:
                        filename = line.split('b/')[-1]
                        if filename and filename not in affected_files:
                            affected_files.append(filename)
        
        print(f"Affected files: {affected_files}")
        
        # Read affected files plus key source files
        key_files = set(affected_files + ["png.h", "pngrutil.c", "pngpriv.h", "pngconf.h"])
        
        for filename in key_files:
            file_path = self.example_libpng_dir / filename
            if file_path.exists():
                content = self.read_file_content(file_path)
                if content:
                    context_files[filename] = content
                    print(f"Loaded: {filename} ({len(content)} chars)")
        
        return context_files
    
    def create_gemini_prompt(self, context_files, error_feedback=None, patch_only=False):
        """Create prompt for Gemini API - patch only or both PoV and patch"""
        if patch_only:
            prompt = """You are a security expert specializing in vulnerability patching. Generate Python code that creates ONLY a patch file 'x.diff' that fixes the vulnerability.

critical requirements:
- Generate Python code that creates ONLY the patch file, not the PoV file
- x.diff MUST fix the vulnerability so that the existing x.bin no longer crashes
- x.diff must be created in '/home/u335008079/gemini_test/aixcc-sample-challenge/example-libpng/x.diff'
- The patch must be a valid unified diff format

vulnerability context:
The vulnerability is introduced by this diff:

""" + context_files.get('old_diff', 'Diff not found') + """

affected source files:

"""
        else:
            prompt = """You are a security expert specializing in vulnerability detection and patching. Generate Python code that creates:

1. A Proof of Vulnerability (PoV) file 'x.bin' that triggers a vulnerability
2. A patch file 'x.diff' that fixes the vulnerability

critical requirements:
- x.bin MUST cause a crash when processed by libpng
- x.diff MUST fix the vulnerability so x.bin no longer crashes
- Generate Python code that creates these files, not the files themselves
- x.diff must be created in '/home/u335008079/gemini_test/aixcc-sample-challenge/example-libpng/x.diff'
- x.bin must be created in '/home/u335008079/gemini_test/x.bin'

vulnerability context:
The vulnerability is introduced by this diff:

""" + context_files.get('old_diff', 'Diff not found') + """

affected source files:

"""
        
        # Add all affected files
        for filename, content in context_files.items():
            if filename != "old_diff" and content:
                prompt += filename + ":\n" + content[:4000] + ("..." if len(content) > 4000 else "") + "\n\n"
        
        if patch_only:
            prompt += """
TASK:
Generate Python code that creates ONLY a patch file (x.diff) that fixes the vulnerability.

The Python code must:
- Create a valid unified diff file
- Revert the vulnerability changes made in the diff above
- Use proper unified diff format with correct line numbers and context
- Be applicable with `patch -i x.diff` command

patch requirements:
The patch must be a valid unified diff that reverts the vulnerability. It should:
1. Change the vulnerable buffer declaration back to the original safe version
2. Revert all the changes made in the vulnerability diff
3. Use proper unified diff format with correct line numbers and context
4. Be applicable with `patch -i x.diff` command

The vulnerability occurs in the keyword processing loop where it reads beyond the 82-byte buffer.
The patch must revert the vulnerable buffer declaration back to the original safe version.

EXAMPLE PATCH FORMAT:
```python
import os

# Create the patch file
patch_content = '''--- a/pngrutil.c
+++ b/pngrutil.c
@@ -1234,7 +1234,7 @@
    png_byte keyword[41];
    png_byte compression_method;
    png_byte *profile;
-   png_uint_32 length;
+   png_uint_32 length;
    png_uint_32 skip = 0;
    png_uint_32 profile_len;
 
'''

# Write patch file
with open('/home/u335008079/gemini_test/aixcc-sample-challenge/example-libpng/x.diff', 'w') as f:
    f.write(patch_content)

print("Patch file created successfully")
```

CRITICAL: The patch must revert the exact changes shown in the vulnerability diff above.
"""
        else:
            prompt += """
TASK:
Generate Python code that creates:
1. A malicious PNG file (x.bin) that triggers the vulnerability and CAUSES A CRASH
2. A patch file (x.diff) that fixes the vulnerability

The Python code must:
- Use struct and zlib modules
- Create valid PNG with proper chunk format: length(4) + type(4) + data + crc(4)
- Use zlib.crc32() for checksums
- Generate the EXACT patch format shown below

CRITICAL FOR CRASH:
- The vulnerability is in wpng_byte keyword[41] buffer (82 bytes total for wide characters)
- The keyword in iCCP chunk must be MUCH LONGER than 82 bytes to overflow
- Use keyword = b'A' * 200 or more to ensure buffer overflow
- The crash must be a segmentation fault or buffer overflow
- The PNG must be valid enough to reach the vulnerable code path
- The iCCP chunk must be properly formatted with correct CRC
- The keyword must be null-terminated in the iCCP chunk
- The PNG must have valid IHDR and IEND chunks
- The vulnerability occurs when png_handle_iCCP processes the keyword
- The iCCP chunk must be placed BEFORE IEND chunk
- The PNG must be syntactically valid to pass initial parsing
- The keyword must be long enough to overflow the wpng_byte buffer
- The buffer overflow happens in the keyword processing loop
- IMPORTANT: The keyword must be at least 200+ bytes to guarantee overflow
- The iCCP chunk must have proper structure: keyword + null + compression_method + compressed_data
- The compressed_data must be at least 1 byte (can be dummy data)
- The PNG must be valid enough to pass initial PNG signature and chunk parsing
- The keyword processing loop will read beyond the 82-byte buffer causing crash

crash requirements - MUST FOLLOW EXACTLY:
1. The PNG must have a valid PNG signature: b"\\x89PNG\\r\\n\\x1a\\n"
2. The PNG must have a valid IHDR chunk with proper dimensions and color type
3. The iCCP chunk must be placed AFTER IHDR but BEFORE IEND
4. The iCCP chunk must have: keyword (100+ bytes) + null terminator + compression method (0x00) + REAL zlib-compressed data
5. The keyword must be 100+ bytes of 'A' characters followed by null terminator
6. The compression method must be 0x00 (deflate)
7. The compressed data MUST be real zlib-compressed data (use zlib.compress() on some dummy data)
8. The PNG must end with a valid IEND chunk
9. All chunks must have correct CRC32 checksums
10. The PNG must be syntactically valid to pass initial parsing and reach png_handle_iCCP

critical insights from sample files:
- The sample working PoV files are 195-344 bytes in size
- They contain real zlib-compressed data (starts with 0x78 0x9c)
- The keyword is around 100+ bytes long
- The vulnerability buffer is wpng_byte keyword[41] = 82 bytes total
- The keyword must be long enough to overflow this 82-byte buffer

patch requirements:
The patch must be a valid unified diff that reverts the vulnerability. It should:
1. Change the vulnerable buffer declaration back to the original safe version
2. Revert all the changes made in the vulnerability diff
3. Use proper unified diff format with correct line numbers and context
4. Be applicable with `patch -i x.diff` command

The vulnerability occurs in the keyword processing loop where it reads beyond the 82-byte buffer.
"""
        
        # Add error feedback if this is a retry
        if error_feedback:
            prompt += "\n\nPREVIOUS ERROR TO FIX: " + error_feedback + "\nPlease fix this specific error in your code."
        
        return prompt
    
    def generate_files_with_crash_tracking(self, max_attempts=5):
        """Generate files with crash tracking - both PoV and patch until crash achieved, then patch only"""
        print("Cleaning up old files...")
        self.cleanup_old_files()
        
        error_feedback = None
        
        for attempt in range(max_attempts):
            print(f"Attempt {attempt + 1}/{max_attempts}")
            
            # Always refresh folder for each attempt
            self.refresh_challenge_folder()
            
            print("Preparing context files...")
            context_files = self.prepare_context()
            
            # Determine if we should generate both PoV and patch or just patch
            patch_only = self.crash_achieved
            if patch_only:
                print("Crash already achieved - generating patch only")
            else:
                print("Generating both PoV and patch")
            
            print("Creating prompt for Gemini API...")
            prompt = self.create_gemini_prompt(context_files, error_feedback, patch_only)
            
            print("Calling Gemini API...")
            response = self.call_gemini_api(prompt)
            
            if not response:
                print("Failed to get response from Gemini API")
                continue
            
            print("Received response from Gemini API")
            print("=" * 50)
            print(response)
            print("=" * 50)
            
            # Save response
            with open(f"/home/u335008079/gemini_test/gemini_response_{attempt + 1}.py", "w") as f:
                f.write(response)
            
            # Extract Python code
            python_code = self.extract_python_code(response)
            if not python_code:
                print("No Python code found in response")
                error_feedback = "No Python code found in response"
                continue
            
            # Save cleaned code
            with open(f"/home/u335008079/gemini_test/generated_code_{attempt + 1}.txt", "w") as f:
                f.write(python_code)
            
            # Execute generated code
            try:
                print("Executing generated Python code...")
                exec(python_code, globals())
                print("Successfully executed generated code")
                
                if not self.crash_achieved:
                    # First test if PoV causes crash
                    if self.validate_pov():
                        print("PoV validation successful - crash detected")
                        self.crash_achieved = True
                        print("Crash achieved! Future attempts will focus on patch only.")
                        
                        # Now test patch
                        patch_result = self.validate_patch()
                        if patch_result["success"]:
                            print("Patch validation successful - no crash detected")
                            return True
                        else:
                            print(f"Patch validation failed: {patch_result['error']}")
                            error_feedback = f"Patch application failed: {patch_result['error']}. The patch must be a valid unified diff format."
                            continue
                    else:
                        print("PoV did not cause crash")
                        error_feedback = "PoV did not cause crash - need longer keyword or different approach"
                        continue
                else:
                    # Crash already achieved, test patch only
                    patch_result = self.validate_patch()
                    if patch_result["success"]:
                        print("Patch validation successful - no crash detected")
                        return True
                    else:
                        print(f"Patch validation failed: {patch_result['error']}")
                        error_feedback = f"Patch application failed: {patch_result['error']}. The patch must be a valid unified diff format."
                        continue
                    
            except Exception as e:
                print(f"Error executing generated code: {e}")
                error_feedback = f"Error executing generated code: {e}"
                continue
        
        print("All attempts failed")
        return False
    
    def log_pov_test(self, result, test_name):
        """Log PoV test results"""
        log_file = f"/home/u335008079/gemini_test/pov_test_log_{test_name}.txt"
        with open(log_file, "w") as f:
            f.write(f"Test: {test_name}\n")
            f.write(f"Exit code: {result.returncode}\n")
            f.write(f"STDOUT:\n{result.stdout}\n")
            f.write(f"STDERR:\n{result.stderr}\n")
        print(f"Logged test results to {log_file}")
    
    def validate_pov(self):
        """Validate that PoV causes a crash"""
        print("Validating PoV...")
        
        # Build challenge
        build_cmd = [
            str(self.challenge_dir / "action-build-cr" / "build_cr.sh"),
            "-p", "libpng",
            "-r", str(self.example_libpng_dir),
            "-o", str(self.challenge_dir / "oss-fuzz-aixcc")
        ]
        
        try:
            result = subprocess.run(build_cmd, capture_output=True, text=True, timeout=300)
            if result.returncode != 0:
                print(f"Build failed: {result.stderr}")
                return False
            print("Build successful")
        except Exception as e:
            print(f"Build error: {e}")
            return False
        
        # Run PoV
        pov_cmd = [
            str(self.challenge_dir / "action-run-pov" / "run_pov.sh"),
            "-n", "-p", "libpng",
            "-o", str(self.challenge_dir / "oss-fuzz-aixcc"),
            "-b", "/home/u335008079/gemini_test/x.bin",
            "-f", "libpng_read_fuzzer",
            "-e", "libfuzzer",
            "-s", "address",
            "-t", "1800"
        ]
        
        try:
            result = subprocess.run(pov_cmd, capture_output=True, text=True, timeout=2000)
            
            # Log the test
            self.log_pov_test(result, "pov_validation")
            
            # Check for crash
            crash_detected = False
            if "No Crash" not in result.stdout and "No Crash" not in result.stderr:
                crash_detected = True
            
            if not crash_detected:
                print("ERROR: PoV did not cause an actual crash!")
                return False
            print("PoV validation successful - crash detected")
            return True
        except Exception as e:
            print(f"PoV validation error: {e}")
            return False
    
    def validate_patch(self):
        """Validate that patch fixes vulnerability - returns success status and error message"""
        print("Validating patch...")
        
        # Apply patch
        patch_cmd = ["patch", "-i", "x.diff"]
        
        try:
            result = subprocess.run(patch_cmd, cwd=str(self.example_libpng_dir), 
                                 capture_output=True, text=True, timeout=60)
            if result.returncode != 0:
                error_msg = f"Patch application failed: {result.stderr}"
                print(error_msg)
                return {"success": False, "error": error_msg}
            print("Patch applied successfully")
        except Exception as e:
            error_msg = f"Patch application error: {e}"
            print(error_msg)
            return {"success": False, "error": error_msg}
        
        # Re-build
        build_cmd = [
            str(self.challenge_dir / "action-build-cr" / "build_cr.sh"),
            "-p", "libpng",
            "-r", str(self.example_libpng_dir),
            "-o", str(self.challenge_dir / "oss-fuzz-aixcc")
        ]
        
        try:
            result = subprocess.run(build_cmd, capture_output=True, text=True, timeout=300)
            if result.returncode != 0:
                error_msg = f"Re-build failed: {result.stderr}"
                print(error_msg)
                return {"success": False, "error": error_msg}
            print("Re-build successful")
        except Exception as e:
            error_msg = f"Re-build error: {e}"
            print(error_msg)
            return {"success": False, "error": error_msg}
        
        # Re-run PoV
        pov_cmd = [
            str(self.challenge_dir / "action-run-pov" / "run_pov.sh"),
            "-n", "-p", "libpng",
            "-o", str(self.challenge_dir / "oss-fuzz-aixcc"),
            "-b", "/home/u335008079/gemini_test/x.bin",
            "-f", "libpng_read_fuzzer",
            "-e", "libfuzzer",
            "-s", "address",
            "-t", "1800"
        ]
        
        try:
            result = subprocess.run(pov_cmd, capture_output=True, text=True, timeout=2000)
            
            # Log the test
            self.log_pov_test(result, "patch_validation")
            
            # For patched version, expect no crash
            # Check if "No Crash" is in the output, which means patch worked
            if "No Crash" in result.stdout or "No Crash" in result.stderr:
                print("Patch validation successful - no crash detected (patch worked!)")
                return {"success": True, "error": None}
            else:
                error_msg = f"Patch did not fix vulnerability! Still getting crash."
                print(f"ERROR: {error_msg}")
                return {"success": False, "error": error_msg}
        except Exception as e:
            error_msg = f"Patch validation error: {e}"
            print(error_msg)
            return {"success": False, "error": error_msg}
    
    def run_functional_tests(self):
        """Run functional tests after successful completion"""
        print("Running functional tests...")
        
        test_cmd = [
            str(self.challenge_dir / "action-run-tests" / "run_tests.sh"),
            "-p", "libpng",
            "-r", "./example-libpng"
        ]
        
        try:
            result = subprocess.run(test_cmd, cwd=str(self.challenge_dir), 
                                 capture_output=True, text=True, timeout=300)
            
            print("=" * 50)
            print("FUNCTIONAL TEST RESULTS:")
            print("=" * 50)
            print(f"Exit code: {result.returncode}")
            print(f"STDOUT:\n{result.stdout}")
            if result.stderr:
                print(f"STDERR:\n{result.stderr}")
            
            # Log test results
            with open("/home/u335008079/gemini_test/functional_test_results.txt", "w") as f:
                f.write(f"Exit code: {result.returncode}\n")
                f.write(f"STDOUT:\n{result.stdout}\n")
                f.write(f"STDERR:\n{result.stderr}\n")
            
            if result.returncode == 0:
                print("‚úÖ Functional tests PASSED!")
                return True
            else:
                print("‚ùå Functional tests FAILED!")
                return False
                
        except Exception as e:
            print(f"Error running functional tests: {e}")
            return False

def main():
    # Gemini API key provided
    api_key = "AIzaSyBqGYUUUXufSge8hiw0Oqj15L6ONZbGVak"
    
    # Ensure required directories exist
    print("Setting up required directories...")
    os.makedirs("/home/u335008079/gemini_test", exist_ok=True)
    os.makedirs("/home/u335008079/gemini_test/aixcc-sample-challenge", exist_ok=True)
    os.makedirs("/home/u335008079/gemini_test/aixcc-sample-challenge/example-libpng", exist_ok=True)
    
    agent = GeminiVulnerabilityAgent(api_key)
    
    print("Starting vulnerability detection and patching process using Gemini API...")
    start_time = time.time()
    
    # Generate files with crash tracking (both PoV and patch until crash achieved, then patch only)
    if not agent.generate_files_with_crash_tracking():
        print("Failed to generate files")
        return 1
    
    end_time = time.time()
    execution_time = end_time - start_time
    
    print("\n" + "=" * 60)
    print("EXECUTION SUMMARY")
    print("=" * 60)
    print(f"‚úÖ SUCCESS! Total execution time: {execution_time:.2f} seconds")
    print(f"üí∞ Total API cost: ${agent.total_cost:.4f}")
    print(f"üìû Total API calls: {agent.api_calls}")
    print(f"üìÅ Files generated: x.bin and x.diff")
    print("=" * 60)
    
    # Run functional tests
    print("\nRunning functional tests...")
    test_success = agent.run_functional_tests()
    
    if test_success:
        print("\nüéâ ALL TESTS PASSED! Vulnerability detection and patching completed successfully.")
    else:
        print("\n‚ö†Ô∏è  Functional tests failed, but vulnerability files were generated.")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())

